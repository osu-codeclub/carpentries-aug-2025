---
title: "Data wrangling with _dplyr_"
author: "Software Carpentry / Jelmer Poelstra"
date: 2025-08-18
editor_options: 
  chunk_output_type: console
---

-------

<br>

## Introduction

### The _dplyr_ package and the tidyverse

The [_dplyr_](https://cran.r-project.org/package=dplyr) package provides very
useful functions for **manipulating data in data frames** ("data wrangling").
In this session, we'll cover the most commonly used ones:

- `select()` to pick columns (variables)
- `filter()` to pick rows (observations)
- `rename()` to change column names
- `arrange()` to change the order of rows (i.e., to sort a data frame)
- `mutate()` to modify values in columns and create new columns
- `summarize()` to compute across-row summaries

All these functions take a
**data frame as the _input_, and output a new, modified data frame**.

_dplyr_ belongs to a family of R packages designed for "dataframe-centric"
data science called the ["tidyverse"](https://www.tidyverse.org).
"Dataframe-centric" refers to doing most if not all data analysis while keeping
the data in R's data frame data structure.
Another tidyverse package we'll cover in today's workshop is _ggplot2_ for making plots.

### Setting up

Use a new script for this session -- much like in the previous session:

1. _Open a new R script_ (Click the **`+`** symbol in toolbar at the top, then click `R Script`)^[
   Or Click `File` => `New file` => `R Script`.].
   
2. _Save the script_ straight away as `data-wrangling.R` --
   you can save it anywhere you like, though it is probably best to save it in a
   folder specifically for this workshop.
   
3. If you want the section headers as comments in your script,
   like in the script I am showing you in the live session,
   then copy-and-paste the following into your script:

<details><summary>Section headers for your script _(Click to expand)_</summary>
```{r}
# 1 - Introduction -------------------------------------------------------------
# 1.3 - Loading the tidyverse

# 1.4 - The gapminder dataset

# 2 - select() to pick columns (variables) -------------------------------------

# 3 - rename() to change column names ------------------------------------------

# 4 - The pipe |> --------------------------------------------------------------

# 5 - filter() to pick rows (observations) -------------------------------------

# Challenge 1
# Write a single command (which can span multiple lines and include pipes) that
# will produce a data frame that has lifeExp, country, and year for Africa but not
# for other continents.
# How many rows does your data frame have?

# 6 - arrange() to sort data frames --------------------------------------------

# 7 - mutate() to modify values in columns and create new columns --------------

# Challenge 2
# A: Use mutate() to create a new column called gdp_billion that has the absolute
#    GDP (i.e., not relative to population size) and does so in units of billions
#    (i.e., 2.3 would mean 2.3 billion).

# B: (Bonus) Use mutate() to create a new column planet that has the value earth
#    in every row. We didnâ€™t cover this kind of scenario but go ahead and test 
#    your intuition!
  
# 8 - summarize() to compute group-wise summary stats --------------------------

# Challenge 3
# Calculate the average life expectancy per country. Which has the longest average
# life expectancy and which has the shortest average life expectancy?

```

</details>

### Loading the tidyverse

All core tidyverse packages can be installed and loaded with a single command.
Since you should already have _installed_ the tidyverse^[
If not: run `install.packages("tidyverse")` now.
], you only need to _load_ it, which you do as follows:

```{r}
library(tidyverse)
```

The output tells you which packages have been loaded as part of the tidyverse.
(You don't have to worry about the ["Conflicts" section](#function-name-conflicts).)

### The `gapminder` dataset

In this session and the next one on data visualization,
we will work with the `gapminder` dataset,
which contains statistics such as population size for different countries across
five-year intervals.

This dataset is available in a package of the same name,
which you also should have already installed^[
If not: run `install.packages("gapminder")` now.
]. To load the package into your current R session:

```{r}
library(gapminder)
```

Take a look at the `gapminder` data frame that is now available to you:

```{r}
gapminder
```

You can also use the `View()` function to look at the data frame.
This will open a new tab in your editor pane with a spreadsheet-like look and feel:

```{r, eval=FALSE}
View(gapminder)
# (Should display the dataset in an editor pane tab)
```

The `gapminder` data frame is a so-called
**"tibble", which is the tidyverse variant of a data frame.**
The main difference is the nicer default printing behavior of tibbles:
e.g. the data types of columns are shown,
and only a limited number of rows are printed.

Each row of this data frame contains statistics for a single country in a specific year
(across five-year intervals between 1952 and 2007), with the following columns:

- `country` (stored as a `factor`,
  [an alternative to `character`](./2_data-structures.qmd#factors) that can be used for categorical data)
- `continent` (stored as a `factor`)
- `year` (stored as an `integer`)
- `lifeExp` (stored as an `integer`): the *life expectancy* in years
- `pop` (stored as an `integer`): the *population size*
- `gdpPercap` (stored as a `double`): the *per-capita GDP*

## `select()` to pick columns (variables)

The first `dplyr` function you'll learn about is `select()`,
which subsets a data frame by including/excluding certain columns.
By default, it only **includes the columns you specify**:

```{r}
select(.data = gapminder, year, country, gdpPercap)
```

In the command above, the first argument was the data frame,
whereas the other arguments were the (unquoted!) names of columns to include^[
Based on what you learned in the previous session,
it may seem strange that the column names should not be quoted.
One way to make sense of this is that the columns can be thought of as objects.].

The **order of the columns** in the output data frame is exactly as you list them in
`select()`, and doesn't need to be the same as in the input data frame.
In other words, `select()` is also one way to reorder columns:
in the example above, we made `year` appear before `country`.

You can also **specify columns that should be excluded**,
by prefacing their name with a `!` (or a `-`):

```{r}
# This will include all columns _except_ continent:
select(.data = gapminder, !continent)
```

::: {.callout-tip appearance='minimal'}
There are also ways to e.g. select _ranges_ of columns,
but that is beyond the scope of this short workshop.
Check the `select()` help by typing `?select` to learn more.
:::

## `rename()` to change column names

The next _dplyr_ function is one of the simplest:
`rename()` to change column names.

The syntax to specify the new and old name within the function is `new_name = old_name`.
For example, to rename the `gdpPercap` column:

```{r}
rename(.data = gapminder, gdp_per_capita = gdpPercap)
```

You can also rename multiple columns at once:

```{r}
rename(.data = gapminder, gdp_per_capita = gdpPercap, life_exp = lifeExp)
```

## The pipe (`|>`)

So far, the examples applied a single _dplyr_ function to a data frame,
and simply printed the output (a new data frame) to screen.

But in practice, it is common to use several functions in succession to "wrangle"
a dataframe into the format you want.
For example, if you want to first `select()` one or more columns,
and _then_ `rename()` a column, you could:

```{r}
gapminder_sel <- select(.data = gapminder, year, country, gdpPercap)

rename(.data = gapminder_sel, gdp_per_capita = gdpPercap)
```

For more elaborate editing, we could go on like we did above,
successively assigning new data frames and moving on to the next step.

But there is a neater way of dong this,
using so-called "piping" with a **pipe operator** (`|>`).
Let's start by seeing a reformulation of the code above with pipes:

```{r}
gapminder |>
  select(year, country, gdpPercap) |>
  rename(gdp_per_capita = gdpPercap)
```

What happened here? We took the `gapminder` data frame,
pushed (or "piped") it into the `select()` function,
and then in turn piped that output into the `rename()` function.

You can think of the pipe as **"then"**:
take `gapminder`, _then_ select, _then_ rename.
Using pipes involves less typing and is especially more readable than using
successive assignments^[
Using pipes is also faster and uses less computer memory.
].

When using pipes, you no longer specify the input data frame with the `.data` argument,
because the function now gets its input via the pipe
(by default, the input goes to the function's first argument).

::: {.callout-tip appearance='minimal'}
For code readability, it is good practice to always start a new line after a pipe `|>`,
and to _indent_ (by pressing Tab) the subsequent line(s).
:::

## `filter()` to pick rows (observations)

### Introduction

The `filter()` function outputs only rows that satisfy one or more conditions.
It is similar to Filter functionality in spreadsheets ---
except that those only change what you _display_, while `filter()` will _remove_ rows.

:::{.callout-warning}
#### Removing data? ðŸ˜±

But if that sounds scary,
recall that all _dplyr_ functions take a data frame as the input,
and output a ***new***, modified data frame.
Therefore, you _only_ modify existing data when assigning the output
back to the input object, like in this example with the `select()` function:

```{r, eval=FALSE}
# Don't run this - illustrative example only
cats <- cats |> select(name, coat)
```
:::

### Filter based on one condition

This first `filter()` example includes observations
(remember, these are countries in a given year)
with a life expectancy exceeding 80 years:

```{r}
gapminder |>
  filter(lifeExp > 80)
```

So, `filter()` will **include rows that satisfy the condition(s)** you specify.
These conditions don't have to be based on numeric comparisons:

```{r}
# Only keep rows where the value in the 'continent' column is 'Europe':
gapminder |>
  filter(continent == "Europe")
```

:::callout-important
### Remember to use _two_ equals signs `==` to test for equality!
:::

### Filter based on multiple conditions

It's also possible to filter based on multiple conditions:

```{r}
gapminder |>
  filter(continent == "Asia", year == 2007, lifeExp > 80)
```

By default, multiple conditions are combined in a Boolean _AND_ fashion.
In other words, in a given row,
_each_ condition needs to be met for that row to be kept.
Above, we showed the countries in Asia that had a life expectancy greater than 80
years in 2007.

If you want to combine conditions in a Boolean _OR_ fashion,
where only one of the conditions needs to be met,
use a `|` between them:

```{r}
# Keep rows with a high life expectancy and/or a high GDP:
gapminder |>
  filter(lifeExp > 80 | gdpPercap > 10000)
```

### Pipeline practice

Finally, let's practice once more with "pipelines" that use multiple _dplyr_ verbs:

```{r}
gapminder |>
  filter(continent == "Americas") |>
  select(year, country, gdpPercap) |>
  rename(gdp_per_capita = gdpPercap)
```

:::exercise
#### {{< fa user-edit >}} **Challenge 1** {-}

Use a single command (which can span multiple lines and include pipes)
to produce a data frame with columns `year`, `country`, and `lifeExp`, 
only for countries in Africa.
How many rows does your data frame have?

<details><summary>Click for the solution</summary>
```{r}
gapminder |>
  filter(continent == "Africa") |>
  select(year, country, lifeExp)
```

It has 624 rows.
</details>

:::

## `arrange()` to sort data frames

The `arrange()` function is like sorting functionality in Excel:
it changes the order of rows based on the values in one or more columns^[
It will always rearrange the order of rows as a whole,
never just of individual columns since that would scramble the data.
].

For example, `gapminder` is currently first sorted alphabetically by `country`,
and next by `year`, but we may instead want to sort by population size:

```{r}
gapminder |>
  arrange(pop)
```

Sorting can help you see the observations with the smallest or largest values
for a certain column: above, we find that the observation with the smallest
population size is _Sao Tome and Principe_ in 1952.

Default sorting is from **small to large**. 
To sort in reverse order,
use the `desc()` (descending, large-to-small) helper function:

```{r}
gapminder |>
  arrange(desc(pop))
```
 
Finally, you may want to sort by multiple columns,
where ties in the first column are broken by a second column (and so on).
Do this by simply listing the columns in the appropriate order:

```{r}
# Sort first by continent, then by country:
gapminder |>
  arrange(continent, country)
```

## `mutate()` to modify columns and create new ones

So far, we've focused on functions that "merely" subset and reorganize data frames.
You've also seen how you can modify column names.
But you haven't seen how you can _change the data_ or _compute derived data_
in data frames.

This can be done with the `mutate()` function.
For example, to create a new column that has population sizes
in millions rather than in individuals:

```{r}
# Create a new column 'pop_million' by dividing 'pop' by a million:
gapminder |>
  mutate(pop_million = pop / 10^6)
```

To _modify_ an existing column rather than adding a new one,
simply "assign back to the same name":

```{r}
gapminder |>
  mutate(pop = pop / 10^6)
```

:::exercise
#### {{< fa user-edit >}} **Challenge 2** {-}

**A:** Use `mutate()` to create a new column `gdp_billion` that has the
       **absolute** GDP (i.e., not relative to population size)
       in **units of billions** (i.e., `2.3` would mean 2.3 billion).

<details><summary>Click for the solution</summary>

```{r}
gapminder |>
    mutate(gdp_billion = gdpPercap * pop / 10^9)
```
</details>

**B:** _(Bonus)_ Use `mutate()` to create a new column `planet` that has the value
`earth` in every row.
We didn't cover this kind of scenario, but go ahead and test your intuition!

<details><summary>Click for the solution</summary>

If you simply provide a value, this will be repeated in every row:

```{r}
gapminder |>
  mutate(planet = "earth")
```
</details>

:::

## `summarize()` to compute summary stats

The final function we'll cover is `summarize()`, which computes data summaries.
For example, to calculate the mean GDP across the entire dataset:

```{r}
gapminder |>
  summarize(mean_GDP = mean(gdpPercap))
```

While this is useful, `summarize()` becomes really powerful in combination with
the helper function `group_by()` to compute **groupwise** stats.
For example, to get the mean mean GDP separately for each continent:

```{r}
gapminder |>
  group_by(continent) |>
  summarize(mean_GDP = mean(gdpPercap))
```

`group_by()` implicitly splits a data frame into groups of rows:
here, one group for observations from each continent.
After that, operations like in `summarize()` will happen separately for each group,
which is how we ended up with per-continent means.

:::exercise
#### {{< fa user-edit >}} **Challenge 3** {-}

Calculate the average life expectancy per country.
Which country has the longest average life expectancy and which has the shortest
average life expectancy?

<details><summary>Click for some hints</summary>
- Since you'll need to examine your output in two ways,
  it makes sense to store the output of the life expectancy calculation in a dataframe.

- Next, an easy way to get rows with lowest and highest values in a column is to
  simply sort by that column and examining the output.
</details>

<details><summary>Click for the solution</summary>

First, let's create a dataframe with the mean life expectancy by country:

```{r}
lifeExp_bycountry <- gapminder |>
   group_by(country) |>
   summarize(mean_lifeExp = mean(lifeExp))
```

Then, arrange that dataframe in two directions to see the countries with the
longest and shortest life expectance --
piping into `head()` as a bonus to only see the top n, here top 1:

```{r}
lifeExp_bycountry |>
   arrange(mean_lifeExp) |>
   head(n = 1)

lifeExp_bycountry |>
   arrange(desc(mean_lifeExp)) |>
   head(n = 1)
```
</details>
:::

<br>

------

## Bonus material for self-study

### Writing and reading tabular data to and from files

When working with your own data in R,
you'll usually need to read data from files into your R environment,
and conversely, to write data that is in your R environment to files.

While it's possible to have R interact with Excel spreadsheet files^[
Using the [readxl](https://readxl.tidyverse.org/) package.
This is installed as part of the tidyverse but is not a _core_ tidyverse package
and therefore needs to be loaded separately: `library(readxl)`.
], storing your data in **plain-text files** generally benefits reproducibility.
Tabular plain text files can be stored using:

- A _Tab_ as the column delimiter
  (often called TSV files, and stored with a `.tsv` extension)
- A _comma_ as the column delimiter
  (often called CSV files, and stored with a `.csv` extension).

To practice writing and reading data to and from TSV files,
The examples below use functions from the _readr_ package.
This package is part of the core tidyverse and therefore already loaded into
your environment.

#### Writing to files

To write the `gapminder` data frame to a TSV file,
use the `write_tsv()` function with argument `x` for the R object
and argument `file` for the file path:

```{r}
write_tsv(x = gapminder, file = "gapminder.tsv")
```

Because we simply provided a file name, the file will have been written in your
R working directory^[
Recall that you can see where that is at the top of the Console tab, or by running `getwd()`.
].

If you want to take a look at the file you just created,
you can find it in RStudio's **Files** tab and click on it,
which will open it in the editor panel.
Of course, you could also find it in your computer's file browser and open it
in different ways.

::: {.callout-note collapse="true"}
### Want to write to a different folder on your computer? _(Click to expand)_

The `file` argument to `write_tsv()` takes a file _path_,
meaning that you can specify any location on your computer for it it in addition
to its name.

For example, if you had a folder called `results` in your current working directory
(directory is just another word for folder), you could put the file in there:

```{r, eval=FALSE}
write_tsv(x = gapminder, file = "results/gapminder.tsv")
```

Note that a forward slash `/` as a folder delimiter will work regardless of your
operating system
(even though Windows natively delimits folder by a backslash `\`).

Finally, if you want to store the file in a totally different place than where
you are now, note that you can also use so-called absolute (or "full") paths like:

```{r, eval=FALSE}
write_tsv(x = gapminder, file = "/Users/poelstra.1/Desktop/gapminder.tsv")
```
:::

#### Reading from files

To practice reading data from a file,
use the `read_tsv()` function on the file you just created: 

```{r}
gapminder_reread <- read_tsv(file = "gapminder.tsv")
```

Note that the function is rather chatty by default,
telling you how many rows and columns it read, and what their data types are.
Let's check the resulting object:

```{r}
gapminder_reread
```

This looks good!
Do note that the column's data types are not identical to what they were
(`year` and `pop` are saved as `double` rather than `integer`,
and `country` and `continent` as `character` rather than `factor`).
This is largely expected because that kind of metadata is not stored in a plain-text
TSV, so `read_tsv()` will by default simply make best guesses as to the types.

Alternatively, you could tell `read_tsv()` what the column types should be,
using the `col_types` argument
(with abbreviations `f` for `factor`, `i` for `integer`, `d` for `double` ---
run `?read_tsv` for more info):

```{r}
read_tsv(file = "gapminder.tsv", col_types = "ffidi")
```

::: {.callout-tip appearance='minimal'}
To read and write CSV files instead, use `read_csv()` / `write_csv()` in the same way.
:::

### Counting rows with `count()` and `n()`

A common operation is simply counting the number of observations for each group.
The _dplyr_ package comes with two related functions that help with this.

For instance, to check the number of countries included in the dataset for the
year 2002, you can use the `count()` function.
It takes the name of one or more columns to define the groups we are interested in,
and can optionally sort the results in descending order with `sort = TRUE`:

```{r}
gapminder |>
    filter(year == 2002) |>
    count(continent, sort = TRUE)
```

If you need to use the number of observations in calculations,
the `n()` function is useful.
It will return the total number of observations in the "_current group_"
as applicable --
for instance, to get the standard error of life expectancy per continent:

```{r}
gapminder |>
  group_by(continent) |>
  summarize(se_life = sd(lifeExp) / sqrt(n()))
```

### Function name conflicts

When you loaded the tidyverse, the output included a  "Conflicts" section that
may have seemed ominous:

```r-out-solo
â”€â”€ Conflicts â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ tidyverse_conflicts() â”€â”€
âœ– dplyr::filter() masks stats::filter()
âœ– dplyr::lag()    masks stats::lag()
â„¹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
```

What this means is that two tidyverse functions, `filter()` and `lag()`,
have the same names as two functions from the _stats_ package that were already
in your R environment.

Those stats package functions are part of what is often referred to as "base R":
core R functionality that is always available (loaded) when you start R.

Due to this function name conflict/collision, for example,
the `filter()` function from _dplyr_ "masks" the `filter()` function from _stats_:
that is, if you write a command with `filter()`, it will use the dplyr function
and not the stats function.

You _can_ still use a "masked" function, but you will need to preface it with its
package name as follows: `stats::filter()`.

### Learn more

The material in this page was adapted from
[this Carpentries lesson episode](https://swcarpentry.github.io/r-novice-gapminder/instructor/12-dplyr.html),
which has a lot more content than we were able to cover today.

Regarding data wrangling specifically,
here are two particularly useful additional skills to learn:

- Pivoting/reshaping ---
  moving between 'wide' and 'long' data formats with `pivot_wider()` and
  `pivot_longer()`. This is covered in
  [episode 13 of the focal Carpentries lesson](https://swcarpentry.github.io/r-novice-gapminder/instructor/13-tidyr.html).

- Joining/merging ---
  combining multiple dataframes based on one or more shared columns.
  This can be done with _dplyr_'s `join_*()` functions --
  see for example [this chapter in R for Data Science](https://r4ds.hadley.nz/joins.html).
  
<br>

```{r, include=FALSE, echo=FALSE}
file.remove("gapminder.tsv")
```
