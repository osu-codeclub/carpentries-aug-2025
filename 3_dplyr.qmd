---
title: "Data wrangling with _dplyr_"
author: "Software Carpentry / Jelmer Poelstra"
date: 2025-08-18
editor_options: 
  chunk_output_type: console
---

-------

<br>

## Introduction

### The _dplyr_ package and the tidyverse

The [_dplyr_](https://cran.r-project.org/package=dplyr) package provides very
useful functions for **manipulating data in data frames** ("data wrangling").
This type of data processing is often essential before you can move on to say,
data visualization (next session of this workshop) or statistical data analysis.

In this session, we'll cover the most commonly used _dplyr_ functions:

- `select()` to pick columns (variables)
- `filter()` to pick rows (observations)
- `rename()` to change column names
- `arrange()` to change the order of rows (i.e., to sort a data frame)
- `mutate()` to modify values in columns and create new columns
- `summarize()` to compute across-row summaries

All these functions take a
**data frame as the _input_, and output a new, modified data frame**.

_dplyr_ belongs to a family of R packages designed for "dataframe-centric"
data science called the ["tidyverse"](https://www.tidyverse.org).
Dataframe-centric refers to doing most if not all data analysis while keeping
the data in R's data frame data structure.
Another tidyverse package we'll cover in today's workshop is _ggplot2_ for making plots.

### Setting up

Use a new script for this session -- much like in the previous session:

1. _Open a new R script_ (Click the **`+`** symbol in toolbar at the top, then click `R Script`)^[
   Or Click `File` => `New file` => `R Script`.].
   
2. _Save the script_ straight away as `data-wrangling.R` --
   you can save it anywhere you like, though it is probably best to save it in a
   folder specifically for this workshop.
   
3. If you want the section headers as comments in your script,
   like in the script I am showing you in the live session,
   then copy-and-paste the following into your script:

<details><summary>Section headers for your script _(Click to expand)_</summary>
```{r}
# 1 - Introduction ----------------------------------------------------
# 1.3 - Loading the tidyverse

# 1.4 - The gapminder dataset

# 2 - select() to pick columns (variables) ----------------------------

# 3 - rename() to change column names ---------------------------------

# 4 - The pipe |> -----------------------------------------------------

# 5 - filter() to pick rows (observations) ----------------------------

# Challenge 1
# Use a "pipeline" like above to output a data frame with
# columns `year`, `country`, and `lifeExp`, only for countries in Africa.
# How many rows does your output data frame have?
  
# 6 - arrange() to sort data frames -----------------------------------

# 7 - mutate() to modify columns and create new ones ------------------

# Challenge 2
# Use mutate() to create a new column called gdp_billion that has the
# absolute GDP (i.e., not relative to population size) and does so in
# units of billions (i.e., 2.3 would mean 2.3 billion).

# 8 - summarize() to compute summary stats ----------------------------

# Challenge 3
# Calculate the average life expectancy per country.
# Which has the longest average life expectancy and which has the
# shortest average life expectancy?
```

</details>

### Loading the tidyverse

All core tidyverse packages can be installed and loaded with a single command.
Since you should already have _installed_ the tidyverse^[
If not: run `install.packages("tidyverse")` now.
], you only need to _load_ it, which you do as follows:

```{r}
library(tidyverse)
```

The output tells you which packages have been loaded as part of the tidyverse.
(For now, you don't have to worry about the
["Conflicts" section](#function-name-conflicts).)

### The `gapminder` dataset

In this session and the next one on data visualization,
we will work with the `gapminder` dataset,
which contains statistics such as population size for different countries across
five-year intervals.

This dataset is available in a package of the same name,
which you also should have already installed^[
If not: run `install.packages("gapminder")` now.
]. To load the package into your current R session:

```{r}
# (Unlike with the tidyverse, no output is expected when you load gapminder)
library(gapminder)
```

Take a look at the `gapminder` data frame that is now available to you:

```{r}
gapminder
```

You can also use the `View()` function to look at the data frame.
This will open a new tab in your editor pane with a spreadsheet-like look and feel:

```{r, eval=FALSE}
View(gapminder)
# (Should display the dataset in an editor pane tab)
```

The `gapminder` data frame is a so-called
**"tibble", which is the tidyverse variant of a data frame.**
The main difference is the nicer default printing behavior of tibbles:
e.g. the data types of columns are shown,
and only a limited number of rows are printed.

Each row of this data frame contains statistics for a single country in a specific year
(across five-year intervals between 1952 and 2007), with the following columns:

- `country` (stored as a `factor`,
  [an alternative to `character`](./2_data-structures.qmd#factors) that can be used for categorical data)
- `continent` (stored as a `factor`)
- `year` (stored as an `integer`)
- `lifeExp` (stored as an `integer`): the *life expectancy* in years
- `pop` (stored as an `integer`): the *population size*
- `gdpPercap` (stored as a `double`): the *per-capita GDP*

## `select()` to pick columns (variables)

The first `dplyr` function you'll learn about is `select()`,
which subsets a data frame by including/excluding certain columns.
By default, it only **includes the columns you specify**:

```{r}
select(.data = gapminder, year, country, pop)
```

Above, the first argument was the data frame,
whereas the other arguments were the (unquoted!) names of columns to be included
in the output data frame^[
Based on what you learned in the previous session,
it may seem strange that the column names should not be quoted.<br><br>
One way to make sense of this is that the columns can be thought of as (vector)
objects, whose names are the column names.].

The **order of the columns** in the output data frame is exactly as you list them in
`select()`, and doesn't need to be the same as in the input data frame.
In other words, `select()` is also one way to reorder columns:
in the example above, we made `year` appear before `country`.

You can also **specify columns that should be excluded**,
by prefacing their name with a `!` (or a `-`):

```{r}
# This will include all columns _except_ continent:
select(.data = gapminder, !continent)
```

::: {.callout-tip appearance='minimal'}
There are also ways to e.g. select _ranges_ of columns that are beyond the scope
of this short workshop.
Check the `select()` help by typing `?select` to learn more.
:::

## `rename()` to change column names

The next _dplyr_ function is one of the simplest:
`rename()` to change column names.

The syntax to specify the new and old name within the function is `new_name = old_name`.
For example, to rename the `gdpPercap` column:

```{r}
rename(.data = gapminder, gdp_per_capita = gdpPercap)
```

## The pipe (`|>`)

Examples so far applied a single _dplyr_ function to a data frame,
simply printing the output (a new data frame) to screen.
But in practice, it's common to use several consecutive _dplyr_ functions to
wrangle a dataframe into the format you want.

For example, you may want to first `select()` one or more columns,
and _then_ `rename()` a column.
You could do that as follows:

```{r}
gapminder_sel <- select(.data = gapminder, year, country, gdpPercap)

rename(.data = gapminder_sel, gdp_per_capita = gdpPercap)
```

And you could go on along these lines,
successively creating new objects that you then use for the next step.

But there is a more elegent way of dong this,
directly sending ("piping") output from one function into the next function
with the **pipe operator** `|>`
(a vertical bar <kbd>|</kbd> followed by a greater-than sign <kbd>></kbd>).
Let's start by seeing a reformulation of the code above with pipes:

```{r}
gapminder |>
  select(year, country, gdpPercap) |>
  rename(gdp_per_capita = gdpPercap)
```

What happened here? We took the `gapminder` data frame,
sent ("piped") it into the `select()` function,
whose output in turn was piped into the `rename()` function.
You can think of the pipe as **"then"**:
take `gapminder`, _then_ select, _then_ rename.

When using the pipe,
you no longer specify the input data frame with the `.data` argument,
because the function now gets its input data via the pipe
(specifically, the input goes to the function's first argument by default).

::: {.callout-tip appearance='minimal'}
Using pipes involves less typing and is especially more readable than using
successive assignments^[
Using pipes is also faster and uses less computer memory.
].

For code readability, 
it is good practice to always start a new line after a pipe `|>`,
and to keep the subsequent line(s) _indented_ as RStudio will automatically do.
:::

## `filter()` to pick rows (observations)

### Introduction

The `filter()` function outputs only those rows that satisfy one or more conditions.
It is similar to Filter functionality in Excel ---
except that those only change what you _display_,
while `filter()` will completely _exclude_ rows.

But if that sounds scary,
recall that _dplyr_ functions always output a ***new*** data frame.
Therefore, with any _dplyr_ function,
you'll only modify existing data when you assign the output back to the input object,
like in this example with the `select()` function:

```{r, eval=FALSE}
# [Don't run this - hypothetical example]
# After running this, any columns in the 'cats' dataframe other than 'name'
# and 'coat' would be removed from it:
cats <- cats |> select(name, coat)
```

### Filter based on one condition

This first `filter()` example outputs only rows for which the
life expectancy exceeds 80 years
(remember, each row represents a country in a given year):

```{r}
gapminder |>
  filter(lifeExp > 80)
```

<details><summary>{{< fa user-edit >}} How many rows were output? _(Click to see the answer)_</summary>
<p>
21 rows were output, as shown in the first line above: `21 x 6` (rows x columns)
</p>
</details>

As the example above demonstrated,
`filter()` **outputs rows that satisfy the condition(s)** you specify.
These conditions don't have to be based on numeric comparisons:

```{r}
# Only keep rows where the value in the 'continent' column is 'Europe':
gapminder |>
  filter(continent == "Europe")
```

:::callout-warning
### Remember to use _two_ equals signs `==` to test for equality!
:::

### Filter based on multiple conditions

It's also possible to filter based on multiple conditions.
For example, you may want to see which countries in Asia had a life expectancy
greater than 80 years in 2007:

```{r}
gapminder |>
  filter(continent == "Asia", year == 2007, lifeExp > 80)
```

Like above, by default, multiple conditions are combined using a Boolean ***AND***.
In other words, in a given row, _each_ condition must be met to output the row.

If you want to combine conditions using a Boolean ***OR***,
where only one of the conditions needs to be met,
use a `|` between the conditions:

```{r}
# Keep rows with a high life expectancy and/or a high GDP:
gapminder |>
  filter(lifeExp > 80 | gdpPercap > 10000)
```

### Pipeline practice

Finally, let's practice another time with "pipelines" that use multiple _dplyr_
functions: `filter` rows, then `select` columns,
and finally `rename` one of the remaining columns:

```{r}
gapminder |>
  filter(continent == "Americas") |>
  select(year, country, gdpPercap) |>
  rename(gdp_per_capita = gdpPercap)
```

:::exercise
#### {{< fa user-edit >}} **Challenge 1** {-}

Use a "pipeline" like above to output a data frame with
columns `year`, `country`, and `lifeExp`, only for countries in Africa.
How many rows does your output data frame have?

<details><summary>Click for the solution</summary>
```{r}
gapminder |>
  filter(continent == "Africa") |>
  select(year, country, lifeExp)
```

The output data frame has 624 rows.
</details>

:::

## `arrange()` to sort data frames

The `arrange()` function is like sorting functionality in Excel:
it changes the order of rows based on the values in one or more columns^[
It will always rearrange the order of rows as a whole,
never just of individual columns since that would scramble the data.
].

`gapminder` is currently first sorted alphabetically by `country`,
and next by `year`.
But you may, for example, want to sort by population size instead:

```{r}
gapminder |>
  arrange(pop)
```

Sorting can help you find observations with the smallest or largest values
for a certain column: above, we see that the smallest population size in
the dataset is _Sao Tome and Principe_ in 1952.

Default sorting is from **small to large**, as seen above .
To sort in reverse order, use the `desc()` (descending) helper function:

```{r}
gapminder |>
  arrange(desc(pop))
```
 
Finally, you may want to sort by multiple columns,
where ties in the first column are broken by a second column (and so on).
Do this by simply listing the columns in the appropriate order:

```{r}
# Sort first by continent, then by country:
gapminder |>
  arrange(continent, country)
```

## `mutate()` to modify columns and create new ones

So far, we've focused on functions that subset and reorganize data frames
(and you've seen how to modify column names).
But you haven't seen how you can _change the data_ or _compute derived data_.

This can be done with the `mutate()` function.
For example, to create a new column that has population sizes
in millions rather than in individuals:

```{r}
# Create a new column 'pop_million' by dividing 'pop' by a million:
gapminder |>
  mutate(pop_million = pop / 10^6)
```

To _modify_ an existing column rather than adding a new one,
simply "assign back to the same name":

```{r}
# Change the unit of the 'pop' column:
gapminder |>
  mutate(pop = pop / 10^6)
```

:::exercise
#### {{< fa user-edit >}} **Challenge 2** {-}

Use `mutate()` to create a new column `gdp_billion` that has the
**absolute** GDP (i.e., not relative to population size)
in **units of billions** (i.e., `2.3` would mean 2.3 billion).

<details><summary>Click for the solution</summary>

You need to do two things, which can be combined into a single line:

1. Make the GDP absolute by multiplying by the population size: `gdpPercap * pop`
2. Change the unit of the absolute GDP to billions by dividing by a billion:
   ` / 10^9`

```{r}
gapminder |>
    mutate(gdp_billion = gdpPercap * pop / 10^9)
```
</details>
:::

## `summarize()` to compute summary stats

The final function _dplyr_ function we'll cover is `summarize()`,
which computes **summaries of your data across rows**.
For example, to calculate the mean GDP across the entire dataset (all rows):

```{r}
# The syntax is similar to 'mutate': <new-column> = <operation>
gapminder |>
  summarize(mean_gdp = mean(gdpPercap))
```

The output is still a dataframe, but unlike with all previous _dplyr_ functions,
it is completely different from the input dataframe,
"collapsing" the data down to as little as a single number, like above. 

`summarize()` becomes really powerful in combination with the helper function
`group_by()` to compute **groupwise** stats.
For example, to get the mean GDP separately for each continent:

```{r}
gapminder |>
  group_by(continent) |>
  summarize(mean_gdp = mean(gdpPercap))
```

`group_by()` implicitly splits a data frame into groups of rows:
here, one group for observations from each continent.
After that, operations like in `summarize()` will happen separately for each group,
which is how we ended up with per-continent means.

:::exercise
#### {{< fa user-edit >}} **Challenge 3** {-}

Calculate the average life expectancy per country.
Which country has the longest average life expectancy and which has the shortest
average life expectancy?

<details><summary>Click for some hints</summary>
- Since you'll need to examine your output in two ways,
  it makes sense to store the output of the life expectancy calculation in a dataframe.

- Next, an easy way to get rows with lowest and highest values in a column is to
  simply sort by that column and examining the output.
</details>

<details><summary>Click for the solution</summary>

First, create a dataframe with the mean life expectancy by country:

```{r}
lifeExp_bycountry <- gapminder |>
   group_by(country) |>
   summarize(mean_lifeExp = mean(lifeExp))
```

Then, arrange that dataframe in two directions to see the countries with the
longest and shortest life expectancy.
You could optionally pipe into `head()` to only see the top `n`, here top 1:

```{r}
lifeExp_bycountry |>
   arrange(mean_lifeExp) |>
   head(n = 1)

lifeExp_bycountry |>
   arrange(desc(mean_lifeExp)) |>
   head(n = 1)
```
</details>
:::

<br>

------

## Bonus material for self-study

### Writing and reading tabular data to and from files

When working with your own data in R,
you'll usually need to read data from files into your R environment,
and conversely, to write data that is in your R environment to files.

While it's possible to make R interact with Excel spreadsheet files^[
Using the [readxl](https://readxl.tidyverse.org/) package.
This is installed as part of the tidyverse but is not a _core_ tidyverse package
and therefore needs to be loaded separately: `library(readxl)`.
], storing your data in **plain-text files** generally benefits reproducibility.
Tabular plain text files can be stored using:

- A _Tab_ as the column delimiter
  (often called TSV files, and stored with a `.tsv` extension)
- A _comma_ as the column delimiter
  (often called CSV files, and stored with a `.csv` extension).

To practice writing and reading data to and from TSV files,
the examples below use functions from the _readr_ package.
This package is part of the core tidyverse and therefore already loaded into
your environment.

#### Writing to files

To write the `gapminder` data frame to a TSV file,
use the `write_tsv()` function with argument `x` for the R object
and argument `file` for the file path:

```{r}
write_tsv(x = gapminder, file = "gapminder.tsv")
```

Because we simply provided a file name, the file will have been written in your
R working directory^[
Recall that you can see where that is at the top of the Console tab, or by running `getwd()`.
].

If you want to take a look at the file you just created,
you can find it in RStudio's **Files** tab and click on it,
which will open it in the editor panel.
Of course, you could also find it in your computer's file browser and open it
in different ways.

::: {.callout-note collapse="true"}
### Want to write to a different folder on your computer? _(Click to expand)_

The `file` argument to `write_tsv()` takes a file _path_,
meaning that you can specify any location on your computer for it,
in addition to the file name.

For example, if you had a folder called `results` in your current working directory,
you could save the file in there like so:

```{r, eval=FALSE}
write_tsv(x = gapminder, file = "results/gapminder.tsv")
```

_Note that a forward slash `/` as a folder delimiter will work regardless of your_
_operating system_
_(even though Windows natively delimits folder by a backslash `\`)._

Finally,
if you want to store the file in a totally different place than your working dir,
it's good to know that you can also use a so-called absolute (or "full") path.
For example:

```{r, eval=FALSE}
write_tsv(x = gapminder, file = "/Users/poelstra.1/Desktop/gapminder.tsv")
```
:::

#### Reading from files

To practice reading data from a file,
use the `read_tsv()` function on the file you just created: 

```{r}
gapminder_reread <- read_tsv(file = "gapminder.tsv")
```

Note that this function is rather chatty,
telling you how many rows and columns it read, and what their data types are.
Let's check the resulting object:

```{r}
gapminder_reread
```

This looks good!
Do note that the column's data types are not identical to what they were
(`year` and `pop` are saved as `double` rather than `integer`,
and `country` and `continent` as `character` rather than `factor`).
This is largely expected because that kind of metadata is not stored in a plain-text
TSV, so `read_tsv()` will by default simply make best guesses as to the types.

Alternatively, you could tell `read_tsv()` what the column types should be,
using the `col_types` argument
(with abbreviations `f` for `factor`, `i` for `integer`, `d` for `double` ---
run `?read_tsv` for more info):

```{r}
read_tsv(file = "gapminder.tsv", col_types = "ffidi")
```

::: {.callout-tip appearance='minimal'}
To read and write CSV files instead, use `read_csv()` / `write_csv()` in the same way.
:::

### Counting rows with `count()` and `n()`

A common operation is simply counting the number of observations for each group.
The _dplyr_ package comes with two related functions that help with this.

For instance, to check the number of countries included in the dataset for the
year 2002, you can use the `count()` function.
It takes the name of one or more columns to define the groups we are interested in,
and can optionally sort the results in descending order with `sort = TRUE`:

```{r}
gapminder |>
    filter(year == 2002) |>
    count(continent, sort = TRUE)
```

If you need to use the number of observations in calculations,
the `n()` function is useful.
It will return the total number of observations in the "_current group_"
as applicable --
for instance, to get the standard error of life expectancy per continent:

```{r}
gapminder |>
  group_by(continent) |>
  summarize(se_life = sd(lifeExp) / sqrt(n()))
```

### Function name conflicts

When you loaded the tidyverse, the output included a  "Conflicts" section that
may have seemed ominous:

```r-out-solo
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors
```

What this means is that two tidyverse functions, `filter()` and `lag()`,
have the same names as two functions from the _stats_ package that were already
in your R environment.

Those stats package functions are part of what is often referred to as "base R":
core R functionality that is always available (loaded) when you start R.

Due to this function name conflict/collision,
the `filter()` function from _dplyr_ "masks" the `filter()` function from _stats_.
Therefore, if you write a command with `filter()`,
it will use the _dplyr_ function and not the _stats_ function.

You _can_ use a "masked" function,
by prefacing it with its package name as follows: `stats::filter()`.

### Using the pipe keyboard shortcut

The following RStudio keyboard shortcut will insert a pipe symbol:
<kbd>Ctrl/Cmd</kbd> + <kbd>Shift</kbd> + <kbd>M</kbd>.

However, by default this (still) inserts an older pipe symbol, `%>%`.
As long as you've loaded the tidyverse^[
This symbol only works when you have one of the tidyverse packages loaded.
], it would not really be a problem to just use `%>%` instead of `|>`.
But it would be preferred to make RStudio insert the `|>` pipe symbol:

1. Click `Tools` > `Global Options` > `Code` tab on the right
2. Check the box "Use native pipe operator" as shown below
3. Click `OK` at the bottom of the options dialog box to apply the change and
   close the box.  

![](./img/pipe-shortcut.png){fig-align="center"}

### Learn more

The material in this page was adapted from
[this Carpentries lesson episode](https://swcarpentry.github.io/r-novice-gapminder/instructor/12-dplyr.html),
which has a lot more content than we were able to cover today.

Regarding data wrangling specifically,
here are two particularly useful additional skills to learn:

- Pivoting/reshaping ---
  moving between 'wide' and 'long' data formats with `pivot_wider()` and
  `pivot_longer()`. This is covered in
  [episode 13 of the focal Carpentries lesson](https://swcarpentry.github.io/r-novice-gapminder/instructor/13-tidyr.html).

- Joining/merging ---
  combining multiple dataframes based on one or more shared columns.
  This can be done with _dplyr_'s `join_*()` functions --
  see for example [this chapter in R for Data Science](https://r4ds.hadley.nz/joins.html).
  
<br>

```{r, include=FALSE, echo=FALSE}
file.remove("gapminder.tsv")
```
